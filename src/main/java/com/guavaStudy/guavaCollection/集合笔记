关联可变集合和不可变集合：
可变集合接口	             属于JDK还是Guava	        不可变版本
Collection	                JDK	             ImmutableCollection
List	                    JDK	             ImmutableList
Set	                        JDK	             ImmutableSet
SortedSet/NavigableSet	    JDK	             ImmutableSortedSet
Map	                        JDK	             ImmutableMap
SortedMap	                JDK	             ImmutableSortedMap

Multiset	                Guava	         ImmutableMultiset
SortedMultiset	            Guava	         ImmutableSortedMultiset
Multimap	                Guava	         ImmutableMultimap
ListMultimap	            Guava	         ImmutableListMultimap
SetMultimap	                Guava	         ImmutableSetMultimap
BiMap	                    Guava	         ImmutableBiMap
ClassToInstanceMap	        Guava	         ImmutableClassToInstanceMap
Table	                    Guava	         ImmutableTable

创建对象的不可变拷贝是一项很好的防御性编程技巧。Guava 为所有 JDK 标准集合类型和 Guava 新集合类型
都提供了简单易用的不可变版本。

JDK 也提供了 Collections.unmodifiableXXX 方法把集合包装为不可变形式，但我们认为不够好：
• 笨重而且累赘：不能舒适地用在所有想做防御性拷贝的场景；
• 不安全：要保证没人通过原集合的引用进行修改，返回的集合才是事实上不可变的；
• 低效：包装过的集合仍然保有可变集合的开销，比如并发修改的检查、散列表的额外空间，等等。

如果你没有修改某个集合的需求，或者希望某个集合保持不变时，把它防御性地拷贝到不可变集合是个很好的实践。

重要提示：所有 Guava 不可变集合的实现都不接受 null 值。我们对 Google 内部的代码库做过详细研究，发现
只有 5%的情况需要在集合中允许 null 元素，剩下的 95%场景都是遇到 null 值就快速失败。如果你需要在不可
变集合中使用 null，请使用 JDK 中的 Collections.unmodifiableXXX 方法。更多细节建议请参考“使用和避免
null”。

##Multiset
/**
 * Guava 提供了一个新集合类型 Multiset，它可以多次添加相等的元素。维基百科从数学角度这样定义 Multise
 * t：”集合[set]概念的延伸，它的元素可以重复出现…与集合[set]相同而与元组[tuple]相反的是，Multiset 元素的
 * 顺序是无关紧要的：Multiset {a, a, b}和{a, b, a}是相等的”。——译者注：这里所说的集合[set]是数学上的概
 * 念，Multiset继承自 JDK 中的 Collection 接口，而不是 Set 接口，所以包含重复元素并没有违反原有的接口契
 * 约。
 */

 可以用两种方式看待 Multiset：
 • 没有元素顺序限制的 ArrayList
 • Map<E, Integer>，键为元素，值为计数
 Guava 的 Multiset API 也结合考虑了这两种方式：
 当把 Multiset 看成普通的 Collection 时，它表现得就像无序的 ArrayList：

 • add(E)添加单个给定元素
 • iterator()返回一个迭代器，包含 Multiset 的所有元素（包括重复的元素）
 • size()返回所有元素的总个数（包括重复的元素）
 当把 Multiset 看作 Map<E, Integer>时，它也提供了符合性能期望的查询操作：
 • count(Object)返回给定元素的计数。HashMultiset.count 的复杂度为 O(1)，TreeMultiset.count 的复杂
 度为 O(log n)。
 • entrySet()返回 Set<Multiset.Entry>，和 Map 的 entrySet 类似。
 • elementSet()返回所有不重复元素的 Set，和 Map 的 keySet()类似。
 • 所有 Multiset 实现的内存消耗随着不重复元素的个数线性增长。

Multiset.addAll(Collection)可以添加 Collection 中的所有元素并进行计数，这比用 for 循环往 Map 添加元素和计数
方便多了。

方法 描述
count(E) 给定元素在 Multiset 中的计数
elementSet() Multiset 中不重复元素的集合，类型为 Set<E>
entrySet() 和 Map 的 entrySet 类似，返回 Set<Multiset.Entry<E>>，其中包含的 Entry 支
持 getElement()和 getCount()方法
add(E, int) 增加给定元素在 Multiset 中的计数
remove(E, int) 减少给定元素在 Multiset 中的计数
setCount(E, int) 设置给定元素在 Multiset 中的计数，不可以为负数
size() 返回集合元素的总个数（包括重复的元素）


>>Multiset 不是 Map
请注意，Multiset不是 Map<E, Integer>，虽然 Map 可能是某些 Multiset 实现的一部分。准确来说 Multiset
是一种 Collection 类型，并履行了 Collection 接口相关的契约。关于 Multiset 和 Map 的显著区别还包括：
• Multiset 中的元素计数只能是正数。任何元素的计数都不能为负，也不能是 0。elementSet()和 entrySe
t()视图中也不会有这样的元素。
• multiset.size()返回集合的大小，等同于所有元素计数的总和。对于不重复元素的个数，应使用 elementSe
t().size()方法。（因此，add(E)把 multiset.size()增加 1）
• multiset.iterator()会迭代重复元素，因此迭代长度等于 multiset.size()。
• Multiset 支持直接增加、减少或设置元素的计数。setCount(elem, 0)等同于移除所有 elem。
• 对 multiset 中没有的元素，multiset.count(elem)始终返回 0。

>>Multiset 的各种实现:
Guava 提供了多种 Multiset 的实现，大致对应 JDK 中 Map 的各种实现：
Map                     对应的Multiset                  是否支持null元素
HashMap                 HashMultiset                        是
TreeMap                 TreeMultiset                        是（如果 comparator 支持的话）
LinkedHashMap           LinkedHashMultiset                  是
ConcurrentHashMap       ConcurrentHashMultiset              否
ImmutableMap            ImmutableMultiset                   否

##SortedMultiset
SortedMultiset 是 Multiset 接口的变种，它支持高效地获取指定范围的子集。比方说，你可以用 latencies.sub
Multiset(0,BoundType.CLOSED, 100, BoundType.OPEN).size()来统计你的站点中延迟在 100 毫秒以内的
访问，然后把这个值和 latencies.size()相比，以获取这个延迟水平在总体访问中的比例。
TreeMultiset 实现 SortedMultiset 接口。在撰写本文档时，ImmutableSortedMultiset 还在测试和 GWT 的
兼容性。

SortedMultiset 是 Multiset 接口的变种，它支持高效地获取指定范围的子集。比方说，你可以用 latencies.sub
Multiset(0,BoundType.CLOSED, 100, BoundType.OPEN).size()来统计你的站点中延迟在 100 毫秒以内的
访问，然后把这个值和 latencies.size()相比，以获取这个延迟水平在总体访问中的比例。